<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>X-Geo-Precision Mapper | 高精度位置情報検索ツール</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet" />
    <script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>
    <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" />

    <style>
        body { margin: 0; padding: 0; overflow: hidden; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; }
        #map { position: absolute; top: 0; bottom: 0; width: 100%; }
        .sidebar { height: 100vh; overflow-y: auto; z-index: 10; background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(8px); }
        .custom-marker { cursor: move; }
        .radius-handle { cursor: ew-resize; }
        /* MapLibre Canvas Outline Fix */
        .maplibregl-canvas { outline: none !important; }
    </style>
</head>
<body class="bg-gray-100">

    <div class="relative flex h-screen">
        
        <aside class="sidebar w-96 shadow-2xl flex flex-col border-r border-gray-200">
            <div class="p-6 border-b border-gray-200 bg-white">
                <h1 class="text-xl font-bold text-gray-800 flex items-center gap-2">
                    <i class="fa-brands fa-x-twitter"></i> Geo-Precision
                </h1>
                <p class="text-xs text-gray-500 mt-1">X(Twitter) 特殊検索コマンド生成ツール</p>
            </div>

            <div class="p-4 bg-gray-50 border-b border-gray-200">
                <label class="text-sm font-semibold text-gray-700 block mb-2">配置モード</label>
                <div class="grid grid-cols-2 gap-2">
                    <button onclick="setMode('positive')" id="btn-pos" class="flex items-center justify-center gap-2 py-2 px-4 rounded-lg border-2 border-blue-500 bg-blue-50 text-blue-700 font-bold transition-all">
                        <i class="fa-solid fa-plus-circle"></i> 検索対象
                    </button>
                    <button onclick="setMode('negative')" id="btn-neg" class="flex items-center justify-center gap-2 py-2 px-4 rounded-lg border-2 border-transparent bg-white text-gray-600 hover:border-red-300 transition-all">
                        <i class="fa-solid fa-minus-circle"></i> 除外対象
                    </button>
                </div>
            </div>

            <div class="flex-1 overflow-y-auto p-4">
                <h2 class="text-sm font-bold text-gray-400 uppercase tracking-widest mb-4">レイヤー管理</h2>
                <div id="layer-list" class="space-y-3">
                    <p id="empty-msg" class="text-center text-gray-400 py-10 text-sm italic">地図をクリックして円を配置してください</p>
                </div>
            </div>

            <div class="p-4 bg-gray-900 text-white shadow-inner">
                <div class="flex justify-between items-center mb-2">
                    <span class="text-xs font-bold text-blue-400">COMMAND OUTPUT</span>
                    <button onclick="copyToClipboard()" class="text-xs bg-gray-700 hover:bg-gray-600 px-2 py-1 rounded transition">
                        <i class="fa-regular fa-copy"></i> Copy
                    </button>
                </div>
                <div id="output-command" class="text-sm font-mono break-all line-clamp-4 min-h-[4.5em] text-gray-300">
                    </div>
                <button onclick="openInTwitter()" class="w-full mt-4 bg-blue-500 hover:bg-blue-400 text-white font-bold py-2 rounded-lg transition-colors flex items-center justify-center gap-2">
                    <i class="fa-brands fa-x-twitter"></i> Xで検索を開く
                </button>
            </div>
        </aside>

        <main class="flex-1 relative">
            <div id="map"></div>
            
            <div class="absolute top-4 right-4 flex flex-col gap-2">
                <button onclick="clearAll()" class="bg-white p-3 rounded-full shadow-lg hover:bg-red-50 text-red-500 transition-all" title="全消去">
                    <i class="fa-solid fa-trash-can"></i>
                </button>
                <button onclick="saveSession()" class="bg-white p-3 rounded-full shadow-lg hover:bg-green-50 text-green-600 transition-all" title="保存">
                    <i class="fa-solid fa-floppy-disk"></i>
                </button>
            </div>
        </main>
    </div>

    <script>
        /**
         * CONFIGURATION & CONSTANTS
         */
        const CONFIG = {
            center: [34.7818, 32.0853], // Tel Aviv, Israel
            defaultRadius: 50, // km
            colors: {
                positive: '#3b82f6', // Blue-500
                negative: '#ef4444', // Red-500
                posFill: 'rgba(59, 130, 246, 0.2)',
                negFill: 'rgba(239, 68, 68, 0.2)'
            }
        };

        /**
         * APP STATE
         */
        let state = {
            mode: 'positive', // or 'negative'
            geofences: [], // Array of { id, lat, lng, radius, type, active }
            map: null,
            markers: {} // Map object to store marker instances by geofence id
        };

        /**
         * INITIALIZATION
         */
        document.addEventListener('DOMContentLoaded', () => {
            initMap();
            loadSession();
        });

        function initMap() {
            state.map = new maplibregl.Map({
                container: 'map',
                style: 'https://tile.openstreetmap.jp/styles/osm-bright-ja/style.json',
                center: CONFIG.center,
                zoom: 7
            });

            state.map.on('click', (e) => {
                // Ignore clicks if they hit a marker or handle (handled by marker events)
                if (e.originalEvent.target.classList.contains('maplibregl-canvas')) {
                    addGeofence(e.lngLat.lat, e.lngLat.lng);
                }
            });

            state.map.on('load', () => {
                console.log("Map Loaded Successfully");
                updateMapLayers();
            });
        }

        /**
         * CORE LOGIC: GEOFENCE MANAGEMENT
         */

        function setMode(mode) {
            state.mode = mode;
            document.getElementById('btn-pos').className = mode === 'positive' 
                ? 'flex items-center justify-center gap-2 py-2 px-4 rounded-lg border-2 border-blue-500 bg-blue-50 text-blue-700 font-bold transition-all'
                : 'flex items-center justify-center gap-2 py-2 px-4 rounded-lg border-2 border-transparent bg-white text-gray-600 transition-all';
            
            document.getElementById('btn-neg').className = mode === 'negative' 
                ? 'flex items-center justify-center gap-2 py-2 px-4 rounded-lg border-2 border-red-500 bg-red-50 text-red-700 font-bold transition-all'
                : 'flex items-center justify-center gap-2 py-2 px-4 rounded-lg border-2 border-transparent bg-white text-gray-600 transition-all';
        }

        function addGeofence(lat, lng, radius = CONFIG.defaultRadius, type = state.mode) {
            const id = 'gf-' + Date.now();
            const fence = {
                id,
                lat,
                lng,
                radius,
                type, // 'positive' or 'negative'
                active: true,
                name: `${type === 'positive' ? '対象' : '除外'}: ${lat.toFixed(2)},${lng.toFixed(2)}`
            };

            state.geofences.push(fence);
            renderUI();
            updateMapLayers();
        }

        function deleteGeofence(id) {
            state.geofences = state.geofences.filter(f => f.id !== id);
            if (state.markers[id]) {
                state.markers[id].center.remove();
                if (state.markers[id].handle) state.markers[id].handle.remove();
                delete state.markers[id];
            }
            renderUI();
            updateMapLayers();
        }

        function toggleActive(id) {
            const fence = state.geofences.find(f => f.id === id);
            if (fence) fence.active = !fence.active;
            renderUI();
            updateMapLayers();
        }

        /**
         * MAP RENDERING & INTERACTION
         */

        function updateMapLayers() {
            if (!state.map.isStyleLoaded()) return;

            state.geofences.forEach(fence => {
                const sourceId = `source-${fence.id}`;
                const layerId = `layer-${fence.id}`;

                // Create or Update Circle Polygon Data
                const circlePolygon = turf.circle([fence.lng, fence.lat], fence.radius, { units: 'kilometers' });

                if (!state.map.getSource(sourceId)) {
                    state.map.addSource(sourceId, { type: 'geojson', data: circlePolygon });
                    state.map.addLayer({
                        id: layerId,
                        type: 'fill',
                        source: sourceId,
                        paint: {
                            'fill-color': fence.type === 'positive' ? CONFIG.colors.posFill : CONFIG.colors.negFill,
                            'fill-outline-color': fence.type === 'positive' ? CONFIG.colors.positive : CONFIG.colors.negative,
                            'fill-opacity': fence.active ? 1 : 0
                        }
                    });
                    createMarkers(fence);
                } else {
                    state.map.getSource(sourceId).setData(circlePolygon);
                    state.map.setPaintProperty(layerId, 'fill-opacity', fence.active ? 1 : 0);
                    updateMarkerPositions(fence);
                }
            });

            // Cleanup removed layers
            const currentIds = state.geofences.map(f => f.id);
            state.map.getStyle().layers.forEach(layer => {
                if (layer.id.startsWith('layer-gf-')) {
                    const id = layer.id.replace('layer-', '');
                    if (!currentIds.includes(id)) {
                        state.map.removeLayer(layer.id);
                        state.map.removeSource(`source-${id}`);
                    }
                }
            });

            generateCommand();
        }

        function createMarkers(fence) {
            // Center Marker
            const el = document.createElement('div');
            el.className = `custom-marker w-4 h-4 rounded-full border-2 border-white shadow-lg`;
            el.style.backgroundColor = fence.type === 'positive' ? CONFIG.colors.positive : CONFIG.colors.negative;
            
            const marker = new maplibregl.Marker({ element: el, draggable: true })
                .setLngLat([fence.lng, fence.lat])
                .addTo(state.map);

            marker.on('drag', () => {
                const lngLat = marker.getLngLat();
                fence.lng = lngLat.lng;
                fence.lat = lngLat.lat;
                updateMapLayers();
            });

            // Radius Handle (Right side of the circle)
            const handleEl = document.createElement('div');
            handleEl.className = 'radius-handle w-3 h-3 bg-white border-2 border-gray-800 rounded-sm shadow-md';
            
            const handle = new maplibregl.Marker({ element: handleEl, draggable: true })
                .setLngLat(getHandlePosition(fence))
                .addTo(state.map);

            handle.on('drag', () => {
                const hLngLat = handle.getLngLat();
                const distance = turf.distance(
                    turf.point([fence.lng, fence.lat]),
                    turf.point([hLngLat.lng, hLngLat.lat]),
                    { units: 'kilometers' }
                );
                fence.radius = Math.max(0.1, distance); // Min 100m
                updateMapLayers();
            });

            state.markers[fence.id] = { center: marker, handle: handle };
        }

        function updateMarkerPositions(fence) {
            const m = state.markers[fence.id];
            if (m) {
                m.center.setLngLat([fence.lng, fence.lat]);
                m.handle.setLngLat(getHandlePosition(fence));
                m.center.getElement().style.display = fence.active ? 'block' : 'none';
                m.handle.getElement().style.display = fence.active ? 'block' : 'none';
            }
        }

        function getHandlePosition(fence) {
            // Calculate a point at the edge of the circle (eastward)
            const destination = turf.destination(
                turf.point([fence.lng, fence.lat]),
                fence.radius,
                90, // Bearing: East
                { units: 'kilometers' }
            );
            return destination.geometry.coordinates;
        }

        /**
         * UI & COMMAND GENERATION
         */

        function generateCommand() {
            const posCmds = state.geofences
                .filter(f => f.active && f.type === 'positive')
                .map(f => `geocode:${f.lat.toFixed(6)},${f.lng.toFixed(6)},${f.radius.toFixed(1)}km`);

            const negCmds = state.geofences
                .filter(f => f.active && f.type === 'negative')
                .map(f => `-geocode:${f.lat.toFixed(6)},${f.lng.toFixed(6)},${f.radius.toFixed(1)}km`);

            let finalQuery = "";
            if (posCmds.length > 0) {
                finalQuery = posCmds.length > 1 ? `(${posCmds.join(' OR ')})` : posCmds[0];
            }
            if (negCmds.length > 0) {
                finalQuery += (finalQuery ? " " : "") + negCmds.join(' ');
            }

            document.getElementById('output-command').innerText = finalQuery || "コマンドがここに表示されます";
        }

        function renderUI() {
            const list = document.getElementById('layer-list');
            const emptyMsg = document.getElementById('empty-msg');
            list.innerHTML = '';
            
            if (state.geofences.length === 0) {
                emptyMsg.style.display = 'block';
                return;
            }
            emptyMsg.style.display = 'none';

            state.geofences.forEach(f => {
                const item = document.createElement('div');
                item.className = `p-3 rounded-lg border bg-white shadow-sm transition ${f.active ? 'border-gray-200' : 'opacity-50 bg-gray-50'}`;
                item.innerHTML = `
                    <div class="flex items-center justify-between mb-2">
                        <span class="text-xs font-bold ${f.type === 'positive' ? 'text-blue-600' : 'text-red-600'}">
                            ${f.type === 'positive' ? 'ADD' : 'EXCLUDE'}
                        </span>
                        <div class="flex gap-2">
                            <button onclick="toggleActive('${f.id}')" class="text-gray-400 hover:text-gray-600">
                                <i class="fa-solid ${f.active ? 'fa-eye' : 'fa-eye-slash'}"></i>
                            </button>
                            <button onclick="deleteGeofence('${f.id}')" class="text-gray-400 hover:text-red-500">
                                <i class="fa-solid fa-trash"></i>
                            </button>
                        </div>
                    </div>
                    <div class="grid grid-cols-2 gap-2 text-[10px]">
                        <div>
                            <label class="text-gray-400 block">緯度/経度</label>
                            <input type="text" value="${f.lat.toFixed(4)}, ${f.lng.toFixed(4)}" readonly class="bg-transparent font-mono">
                        </div>
                        <div>
                            <label class="text-gray-400 block">半径 (km)</label>
                            <input type="number" step="0.1" value="${f.radius.toFixed(1)}" 
                                onchange="updateFenceRadius('${f.id}', this.value)"
                                class="bg-gray-50 border rounded px-1 w-full font-mono">
                        </div>
                    </div>
                `;
                list.appendChild(item);
            });
        }

        function updateFenceRadius(id, val) {
            const fence = state.geofences.find(f => f.id === id);
            if (fence) {
                fence.radius = parseFloat(val);
                updateMapLayers();
            }
        }

        /**
         * UTILS & PERSISTENCE
         */

        function copyToClipboard() {
            const cmd = document.getElementById('output-command').innerText;
            navigator.clipboard.writeText(cmd).then(() => {
                alert("コマンドをコピーしました！");
            });
        }

        function openInTwitter() {
            const cmd = encodeURIComponent(document.getElementById('output-command').innerText);
            if (!cmd || cmd === "コマンドがここに表示されます") return;
            window.open(`https://twitter.com/search?q=${cmd}&f=live`, '_blank');
        }

        function clearAll() {
            if (confirm("全てのエリアを削除しますか？")) {
                Object.keys(state.markers).forEach(id => {
                    state.markers[id].center.remove();
                    state.markers[id].handle.remove();
                });
                state.markers = {};
                state.geofences = [];
                renderUI();
                updateMapLayers();
            }
        }

        function saveSession() {
            localStorage.setItem('x_geo_mapper_data', JSON.stringify(state.geofences));
            alert("現在のエリア設定を保存しました。");
        }

        function loadSession() {
            const saved = localStorage.getItem('x_geo_mapper_data');
            if (saved) {
                const data = JSON.parse(saved);
                data.forEach(f => addGeofence(f.lat, f.lng, f.radius, f.type));
            }
        }
    </script>
</body>
</html>
